#!/usr/bin/env python3
import argparse
import copy
import os
import pathlib
import re
import shutil
import subprocess
import sys

import six
import yaml

ENCODING = "utf-8"
CONFIG_NAME = ".cmk.yaml"

BUILD_TYPES = [
    {
        "name":
        "Debug",
        "dir":
        "build",
        "flags": [
            '-Wshadow',
            "-fsanitize=address",
            "-fno-omit-frame-pointer",
            "-fno-optimize-sibling-calls",
        ]
    },
    {
        "name": "Release",
        "dir": "build-release",
        "flags": []
    },
    {
        "name":
        "RelWithDebInfo",
        "dir":
        "build-relwithdebinfo",
        "flags": [
            "-fsanitize=address",
            "-fno-omit-frame-pointer",
            "-fno-optimize-sibling-calls",
        ]
    },
]
COMPILE_COMMANDS = "compile_commands.json"
GENERATORS = [
    "Ninja",
    "Unix Makefiles",
]
ACTIONS = [
    "cfg",
    "rm",
    "rcfg",
    "build",
    "install",
]
WHITESPACE_RGX = re.compile(r"\s+")

DEFAULT_CONFIG = {
    "generator": "Ninja",
    "c_compiler": "/usr/bin/clang",
    "cxx_compiler": "/usr/bin/clang++",
    "linker": "/usr/bin/clang",
    "install_dir": "~/.cmake-packages",
    "flags": [
        "-pthread",
        "-fdiagnostics-absolute-paths",
        "-fcolor-diagnostics",
    ],
    "cmake_args": [],
    "static_libs": False,
    "project": {},
}


def _build_dir(build_tuple, source_dir):
    return build_tuple["name"], pathlib.Path(source_dir) / build_tuple["dir"]


def _configure(
    build_tuple,
    source_dir,
    generator,
    c_compiler,
    cxx_compiler,
    linker,
    install_dir,
    flags,
    cmake_args,
    static_libs,
):
    build_type, build_dir = _build_dir(build_tuple, source_dir)
    build_dir.mkdir(exist_ok=True)

    build_shared_libs = "OFF" if static_libs else "ON"
    cmd = f"""cmake
        -B "{build_dir}"
        -S "{source_dir}"
        -G "{generator}"
        -DCMAKE_EXPORT_COMPILE_COMMANDS="ON"
        -DCMAKE_INSTALL_PREFIX="{install_dir}"
        -DCMAKE_PREFIX_PATH="{install_dir}"
        -DCMAKE_BUILD_TYPE="{build_type}"
        -DCMAKE_C_COMPILER="{c_compiler}"
        -DCMAKE_CXX_COMPILER="{cxx_compiler}"
        -DCMAKE_LINKER="{linker}"
        -DBUILD_SHARED_LIBS="{build_shared_libs}"
    """
    args_fmt = [f"-D{i.strip()}" for i in cmake_args]
    cmd = "\n".join([cmd, *args_fmt])
    cmd = WHITESPACE_RGX.sub(" ", cmd)

    flags = " ".join(flags)
    cflags = " ".join([os.getenv("CFLAGS", ""), flags])
    cxxflags = " ".join([os.getenv("CXXFLAGS", ""), flags])
    env = os.environ.copy()
    env.update({"CFLAGS": cflags, "CXXFLAGS": cxxflags})

    result = subprocess.check_call(
        args=cmd,
        shell=True,
        cwd=source_dir,
        env=env,
    )

    if build_tuple == BUILD_TYPES[0]:
        try:
            os.remove(source_dir / COMPILE_COMMANDS)
        except IOError:
            pass
        os.symlink(build_dir / COMPILE_COMMANDS, source_dir / COMPILE_COMMANDS)

    return result


def _clear_config(build_tuple, source, ignore_errors=False):
    try:
        _, build_dir = _build_dir(build_tuple, source)
        shutil.rmtree(build_dir / "CMakeFiles")
        (build_dir / "CMakeCache.txt").unlink()
    except IOError:
        if not ignore_errors:
            six.reraise(*sys.exc_info())


def _build(build_tuple, source_dir, target=None):
    build_type, build_dir = _build_dir(build_tuple, source_dir)
    cmd = f'cmake --build {build_dir} --config {build_type}'
    if target:
        cmd += f' --target {target}'
    cmd += " -- -j 10"
    return subprocess.check_call(
        args=cmd,
        shell=True,
        cwd=source_dir,
    )


def _find_config(source):
    user_config, config_p = None, None
    for i in (source, *list(source.parents)):
        path = pathlib.Path(i) / CONFIG_NAME
        if path.is_file():
            try:
                with open(path, "r", encoding=ENCODING) as fp:
                    user_config = yaml.safe_load(fp)
                    config_p = str(path)
                break
            except IOError:
                pass

    config = copy.copy(DEFAULT_CONFIG)
    if user_config is not None:
        config.update(user_config)
    proj, project_name = config["project"], source.stem.lower()

    if isinstance(proj, dict) and project_name in proj:
        proj = proj[project_name]
        config["cmake_args"] += list(proj.get("cmake", []))
        config["flags"] += list(proj.get("flags", []))
    del config["project"]

    return config, config_p


def _cli_arguments():
    parser = argparse.ArgumentParser(
        prog="cmk",
        description="helper script for cmake",
    )
    parser.add_argument(
        "-i",
        "--install-dir",
        help=f"installation dir",
        default=None,
    )
    parser.add_argument(
        "-g",
        "--generator",
        help=f"cmake generator",
        default=None,
        choices=GENERATORS,
    )
    parser.add_argument(
        "-s",
        "--source-dir",
        help="source dir, default='.'",
        default=".",
    )
    parser.add_argument("action", choices=ACTIONS)
    parser.add_argument(
        "cmake_args",
        nargs="*",
        default=None,
        help="additional cmake variables",
    )
    cli_args = parser.parse_args()
    cli_action = cli_args.action
    source = pathlib.Path(cli_args.source_dir).expanduser().absolute()
    config, config_p = _find_config(source)

    if cli_args.generator is not None:
        config["generator"] = cli_args.generator
    if cli_args.cmake_args is not None:
        config["cmake_args"] += list(cli_args.cmake_args)

    if cli_args.install_dir is not None:
        install_dir = cli_args.install_dir
    else:
        install_dir = config["install_dir"]
    config["install_dir"] = str(
        pathlib.Path(install_dir).expanduser().absolute())

    del cli_args.source_dir
    del cli_args.action
    del cli_args.generator
    del cli_args.cmake_args
    del cli_args.install_dir
    config.update(vars(cli_args))
    return cli_action, source, config_p, config


def main():
    action, source_dir, config_path, args = _cli_arguments()
    print(
        yaml.dump_all([
            {
                "cmd": action,
                "pwd": str(source_dir),
                "config_path": config_path,
            },
            args,
        ]))

    def cfg(btype):
        _configure(btype, source_dir, **args)

    if action == "cfg":
        for t in BUILD_TYPES:
            cfg(t)
    elif action == "rm":
        for t in BUILD_TYPES:
            _clear_config(t, source_dir)
    elif action == "rcfg":
        for t in BUILD_TYPES:
            _clear_config(t, source_dir, ignore_errors=True)
            cfg(t)
    elif action == "build":
        for t in BUILD_TYPES:
            cfg(t)
            _build(t, source_dir)
    elif action == "install":
        for t in BUILD_TYPES:
            cfg(t)
            _build(t, source_dir, target="install")


if __name__ == "__main__":
    main()
